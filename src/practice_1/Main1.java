package practice_1;

import java.util.HashSet;

public class Main1 {

    public static void main(String[] args) {

        int [] numbers = new int[100]; // создан обычный массив с длиной 100
        int num = 1;
        for (int i = 0; i < 100; i++){ // с помощю цикла массив заполняется числами от 1 до 100
            numbers[i] = num;
            num++;

        }

        HashSet <Integer> myHashSet = new HashSet<Integer>(); // создано множество Hashset

        for (int j = 0; j < 100; j++){
            if (numbers[j] % 2 == 0 && numbers[j] % 5 == 0 ){  // Перенос четных чисел, которые делятся на 5 без остатков в HashSet.
                myHashSet.add(numbers[j]);
            }

        }
        System.out.println(myHashSet); // Вывод на консоль перенесенных чисел.

        for (int k = 0; k < 100; k++){
            if (numbers[k] % 2 == 0 && numbers[k] % 5 != 0){ // Перенос остальных четных чисел в HashSet.
                myHashSet.add(numbers[k]);

            }

        }
        System.out.println(myHashSet); // Вывод на консоль перенесенных чисел.

        /* После вывода на консоль мы увидели, что порядок перенесенных чисел изменился.
         * Класс Hashset не гарантирует соблюдение порядка итерации. Главное назначение данного класса
         * заключается в быстром поиске элементов, т.е он часто используется для проверки принадлежности
         * объекта заданному множеству. Алгоритм класса был оптимизирован и усложнен до такой степени, чтобы
         * проверка элементов множества прошла как можно быстро. Исходя из этой логики Hashset
         * упорядочивает элементы в удобном для него варианте. Поэтому при каждом добавлении нового элемента
         * порядок элементов множества может меняться. Возможно, из-за сложности алгоритма ни в каких источниках
         * не дают полного объяснения принципов или правил изменения порядка множества.
         *   */

    }
}
